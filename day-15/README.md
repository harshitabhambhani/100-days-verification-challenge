# 100 Days Verification Challenge - Day 15 - Memories

## 1. What are the different levels of memory? List the pros & cons of each level.

| **Memory Level**   | **Type**        | **Pros**                          | **Cons**                                 |
|--------------------|-----------------|-----------------------------------|------------------------------------------|
| **Primary Memory** | **RAM**         | Fast access (SRAM), High density (DRAM) | Expensive (SRAM), Needs refresh (DRAM) |
|                    | **ROM**         | Non-volatile, Programmable (EEPROM) | Limited reprogramming (PROM), Slow (EEPROM) |
| **Secondary Memory** | **Hard Disk**  | Large capacity, Cost-effective    | Slower access, Mechanical failure        |
|                    | **Magnetic Tape** | Large capacity, Cost-effective for archives | Very slow, Sequential access      |
|                    | **CD/DVD**      | Portable, Durable                 | Limited capacity, Slow                   |
|                    | **Zip Disk**    | Portable, Rewritable              | Limited capacity, Obsolete               |
| **Cache Memory**   | -               | Very fast, Reduces access time    | Expensive, Small capacity                |
| **Register**       | -               | Fastest, Directly accessible      | Very limited size, Expensive             |

## 2. What is memory addressing technique? Explain the various addressing modes?

Memory addressing technique refers to the method used by the CPU to access data in memory. Various addressing modes are:

### a. Immediate Addressing
- The operand is specified directly in the instruction.
- **Example:** `MOV A, #5` (Move the value 5 to register A).

### b. Direct Addressing
- The address of the operand is given in the instruction.
- **Example:** `MOV A, 5000H` (Move the value at memory location 5000H to register A).

### c. Indirect Addressing
- The address of the operand is held in a register or memory location.
- **Example:** `MOV A, (R1)` (Move the value at the address in register R1 to register A).

### d. Register Addressing
- The operand is in a register specified in the instruction.
- **Example:** `MOV A, B` (Move the value in register B to register A).

### e. Indexed Addressing
- The effective address of the operand is generated by adding a constant value to the contents of a register.
- **Example:** `MOV A, 5000H(R1)` (Move the value at memory location 5000H + contents of R1 to register A).

### f. Base Register Addressing
- Similar to indexed addressing but uses a base register.
- **Example:** `MOV A, BASE(R1)` (Move the value at memory location BASE + contents of R1 to register A).

## 3. Address bus consists of 20 bits in a byte-addressable system. Find the size of memory.

The number of addressable locations (size of memory) is calculated as: 2^(number of bits)
So, with a 20-bit address bus:
Size of memory = 2^{20} bytes = 1 MB

## 4. Memory size is 8 GB in a 4-byte addressable system. Find the no. of address bits.

First, convert the memory size to bytes:
8 GB = 8 * 1024 * 1024 * 1024 bytes = 8,589,934,592 bytes

Since the system is 4-byte addressable, each address points to 4 bytes:
Number of addresses = 8,589,934,592 bytes/(4 bytes/address) = 2,147,483,648 addresses

The number of address bits required is:
Number of address bits = log_2(2,147,483,648) = 31

## 5. What is a RAID system (used in SSDs)? Explain with diagram.

RAID (Redundant Array of Independent Disks) is a data storage virtualization technology that combines multiple physical disk drive components into one or more logical units for redundancy or performance improvement.

### Common RAID Levels:
- **RAID 0:** This configuration has striping but no redundancy of data. It offers the best performance, but it does not provide fault tolerance.
- **RAID 1:** Also known as disk mirroring, this configuration consists of at least two drives that duplicate the storage of data. There is no striping. Read performance is improved, since either disk can be read at the same time. Write performance is the same as for single disk storage.
- **RAID 2:** This configuration uses striping across disks, with some disks storing error checking and correcting (ECC) information. RAID 2 also uses a dedicated Hamming code parity, a linear form of ECC. RAID 2 has no advantage over RAID 3 and is no longer used.
- **RAID 3:** This technique uses striping and dedicates one drive to storing parity information. The embedded ECC information is used to detect errors. Data recovery is accomplished by calculating the exclusive information recorded on the other drives. Because an I/O operation addresses all the drives at the same time, RAID 3 cannot overlap I/O. For this reason, RAID 3 is best for single-user systems with long record applications.
- **RAID 4:**  This level uses large stripes, which means a user can read records from any single drive. Overlapped I/O can then be used for read operations. Because all write operations are required to update the parity drive, no I/O overlapping is possible.
- **RAID 5:** This level is based on parity block-level striping. The parity information is striped across each drive, enabling the array to function, even if one drive were to fail. The array's architecture enables read and write operations to span multiple drives. This results in performance better than that of a single drive, but not as high as a RAID 0 array. RAID 5 requires at least three disks, but it is often recommended to use at least five disks for performance reasons.
RAID 5 arrays are generally considered to be a poor choice for use on write-intensive systems because of the performance impact associated with writing parity data. When a disk fails, it can take a long time to rebuild a RAID 5 array.
- **RAID 6:** This technique is similar to RAID 5, but it includes a second parity scheme distributed across the drives in the array. The use of additional parity enables the array to continue functioning, even if two disks fail simultaneously. However, this extra protection comes at a cost. RAID 6 arrays often have slower write performance than RAID 5 arrays.
- **RAID 10:** Combining RAID 1 and RAID 0, this level is often referred to as RAID 10, which offers higher performance than RAID 1, but at a much higher cost. In RAID 1+0, the data is mirrored and the mirrors are striped.

![image](https://github.com/harshitabhambhani/100-days-verification-challenge/assets/109619297/ac2299a0-0d8c-4b65-9b5d-8a3a42dc2758)

![image](https://github.com/harshitabhambhani/100-days-verification-challenge/assets/109619297/812d23cf-3b2c-45d3-b72b-868a17c36970)

![image](https://github.com/harshitabhambhani/100-days-verification-challenge/assets/109619297/42c1d975-489d-4d98-9c9b-7c4fca76f40a)

![image](https://github.com/harshitabhambhani/100-days-verification-challenge/assets/109619297/0a861d1f-0490-40df-9bbf-6f19b0857077)

![image](https://github.com/harshitabhambhani/100-days-verification-challenge/assets/109619297/dcc3e88b-ba12-42b7-bd63-407709160122)

![image](https://github.com/harshitabhambhani/100-days-verification-challenge/assets/109619297/3cf478b8-5edc-418d-8034-2cfdd6f7dd80)

![image](https://github.com/harshitabhambhani/100-days-verification-challenge/assets/109619297/660f2981-a447-49dc-8cab-26908ffc5f9f)

![image](https://github.com/harshitabhambhani/100-days-verification-challenge/assets/109619297/e6d5f74c-0ad7-4a87-b627-c4c95717e255)

## 6. Explain virtual memory with example? Why do we need them?

Virtual memory is a memory management technique that creates an "illusion" of a large (virtually unlimited) memory space, even if the physical memory is limited. It uses both the RAM and a portion of the hard drive (swap space) to simulate more memory than physically available.

**Example:**
A system with 4 GB of RAM can run applications that collectively need 8 GB of memory by using a combination of RAM and disk space.

**Why do we need Virtual Memory?**
- It allows larger programs to run on systems with limited physical memory.
- It provides memory protection and isolation between processes.
- It simplifies memory management and increases system stability.

## 7. What is a wait state in memory? How can we deal with this state?

A wait state is a delay experienced by the CPU when accessing slower memory or peripheral devices. During a wait state, the CPU is idle and waits for the memory or device to complete its operation.

**Dealing with Wait States:**
- **Using faster memory:** Reduce or eliminate wait states by using faster memory components.
- **Cache memory:** Use cache memory to reduce the frequency of direct memory access.
- **Memory interleaving:** Spread memory accesses across multiple memory modules to reduce wait times.
- **Pipeline and parallel processing:** Implement pipelining or parallel processing techniques to overlap memory access with other CPU operations.
